# ССЫЛКА НА ИСТОЧНИК: https://qudata.com/ml/ru/NN_Base_Numpy.html

#region РАЗМЕРНОСТЬ И ФОРМА ТЕНЗОРА

import numpy as np                     #         ndim:    shape:       size: 
                                        
v = np.array( [ 1, 2, 3] )             # вектор:     1     (3,)         3 
                                  
m = np.array( [ [ 1, 2, 3],              
                [ 4, 5, 6] ])          # матрица:    2     (2, 3)       6
                                  
t = np.array( [ [[ 1, 2, 3],              
                 [ 4, 5, 6]],    
                                  
                [[ 7, 8, 9],              
                 [10,11,12]] ])        # тензор:    3      (2, 2, 3)   12

#endregion

#region ОБРАЩЕНИЕ К ВЕКТОРАМ

t1 = np.array( [ 1, 2] )             #  shape = (2,)                 
t2 = np.array( [ [1,2] ] )           #  shape = (1,2)
t3 = np.array( [[1],                 #  shape = (2,1)   
                 [2]])

t1[1] == t2[0,1] == t3[1,0] == 2    #  True

#endregion

#region КАК ИЗМЕНЯТЬ НЕ МЕНЯЯ РАЗМЕР

v = np.array( [1,2,3,4,5,6] )         # shape = (6,)    ndim = 6
m16 = v.reshape( (1,6) )                 # shape = (1,6)   ndim = 6
m23 = v
m23.shape = (2,3)                        # shape = (2,3)   ndim = 6
 
# print(f"{m23} \n\n {v}")                   #  [ [1,2,3],[4,5,6] ]
                           
#endregion

#region ВЫСЧИТЫВАНИЕ САМОСТОЯТЕЛЬНЫХ ДЛИН ТЕНЗОРОВ(ВЕКТОРОВ)

v = np.arange(12)                       # [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
 
m = v.reshape( (3, 4 ) )                # [ 
                                        #   [ 0, 1, 2, 3]
                                        #   [ 4, 5, 6, 7]
                                        #   [ 8, 9, 10, 11] 
                                        # ]
                                        
t = m.reshape( (-1, 2, 3) )             # [ 
                                        #   [
                                        #       [ [0,1,2] [3,4,5] ]
                                        #       [ [6,7,8] [9,10,11] 
                                        #   ]
                                        # ]
               
# print(v.shape, m.shape, t.shape)      # (12,) (3, 4) (2, 2, 3)

#endregion

#region ФУНКЦИИ ДЛЯ ОСЕЙ(ИНДЕКСОВ)

# Зачем точки? 
# Так указан тип float, можно добавить к ones((2, 3), dtype=int)

m = np.ones( (2, 3))                    # матрица 2x3 из единиц:   
                                        # [ 
                                        #     [1. 1. 1.]
                                        #     [1. 1. 1.]
                                        # ]

# print( m.sum(axis=0),                   #  [2. 2. 2.]  сумма по строчкам
#        m.sum(axis=1),                   #  [3. 3.]     суммы по колонками
#        m.sum()  )                       #  6.0         сумма всех элементов

#endregion

#region ВЫБОРКА ПО ИНДЕКСАМ

m = np.arange( 6 ).reshape((2,3))       # [
                                        #   [0, 1, 2],
                                        #   [3, 4, 5]
                                        # ]
                                       
v1 = m[0, :]                          #   [0, 1, 2]
v2 = m[0]                             #   тоже самое (для 1-го индекса)
v3 = m[:, 0]                          #   [0, 3]
 
mm = m[0:2, 0:2]                      # [ 
                                      #     [0, 1], 
                                      #     [3, 4]
                                      # ]
                                      
s = m[:,1]                            # [1 4]
#print(v1,v2,v3,mm, s)

#endregion

#region СМЕНА ЗНАЧЕНИЙ ПО ИНДЕКСУ

# ССЫЛОЧНЫЙ ТИП ПОЛУЧАЕТСЯ
v1[0] = 100
m.reshape(-1)
# print(m)

m[:,0] = -1                           # [[-1,  1,  2],
# print(m)                              #  [-1,  4,  5]]

m[:,1] = 52
#print(m)

#endregion

#region МАТЕМАТИЧЕСКИЕ ФУНКЦИИ

a = np.arange(3)                      # [0, 1, 2]
b = np.arange(3,6)                    # [3, 4, 5]

a + b                                 # [3, 5, 7]
a * b                                 # [0, 4,10]

# print(a + b, a* b)

#endregion

#region МАТЕМАТИЧЕСКИЕ ФУНКЦИИ КОГДА РАЗНЫЕ СТРУКТУРЫ ТЕНЗОРОВ(ВЕКТОРОВ)

m = np.array([ [0, 1],
               [2, 3]])     
                
v = np.array(  [4, 5] )

# 0 1 2 3 + 4 5 4 5 - Дублируются по колонке
#print(m+v)    # [[4, 6],
              #  [6, 8]]
              
v = np.array(  [ [4], [5] ] )

# 0 1 2 3 + 4 4 5 5 - Дублируются по строке
#print(m+v)

#endregion

#region ПРОИЗВЕДЕНИЕ И УМНОЖЕНИЕ ВЕКТОРОВ (ИХ СУММА)

u = np.array( [1,2,3] )
v = np.array( [3,2,1] )
 
#print( np.dot(u,v) )             #  10 = 1*3 + 2*2 + 3*1
#print( u.dot(v)    )             #  10 - тот же результат
#print( np.sum(u*v) )             #  10 - тот же результат

P = np.arange( 6).reshape( (2,3) )  # [ [0 1 2] [3 4 5] ]
Q = np.arange(12).reshape( (3,4) )  # [ [0 1 2 3] [4 5 6 7] [8 9 10 11] ]

# Если строк у первого меньше чем у второго, НО 
# кол-во строк первого равно кол-ву столбцов второго то:
# считать вот так(на примере 1 строки):
# [0 1 2] - первая строка первого
# [0 4 8] - первый столбец второго
# То есть где можем перемножить там и перемножаем:
# 0*0 + 1*4 + 2*8 = 20 - первое значение для них

#print(np.dot(P, Q))     # [ [20 23 26 29] [56 68 80 92] ]
#print(P.dot(Q)  )       # То же самое

P = np.array([1,2])         # (2,) == (1,2)
Q = np.array([[3],[4]])     # (2,1)

# [1 2] - первая строка первого
# [3 4] - первый столбец второго
# 1*3 + 2*4 = 11

#print(np.dot(P, Q)) # [ 11 ] 

#endregion

#region СМЕНА СТОЛБЦОВ И СТРОЧЕК

# При помощи .T или transpose()
a = np.arange(6).reshape(2,3)       # (2, 3) [ [0 1 2] [3 4 5] ]
b = a.T                            # (3, 2) [ [0 3] [1 4] [2 5] ]   

#print(b.shape)                  

v = np.arange(6)                # [0 1 2 3 4 5]
m = v.reshape(3,2)              # [ [0 1] [2 3] [4 5] ]
 
# reshape => [ [0 1] [2 3] [4 5] ] => [0 1 2 3 4 5] => [ [0 1 2] [3 4 5] ]
m1 = m.reshape(2,3)             # [ [0 1 2] [3 4 5] ]     
 
# T => [ [0 1] [2 3] [4 5] ] => [ [0 2 4] [1 3 5] ]
m2 = m.T                        # [ [0 2 4] [1 3 5] ]

#print(m1,m2)

# Ссылочный тип (транспонтирование)
m2[0,0]=52
#print(m)                        #  [ [100 1 2] [  3 4 5] ]

# Если нужно умножить на себя то нужна транспонтировка, 
# (если не квадратная матрица где кол-во столбцов не равно кол-ву строк (3,2) - нет (2,2) - да)
# поскольку не будут совпадать при умножении столбцы
a = np.arange(6).reshape(2,3)       # [ [0 1 2] [3 4 5] ] (2,3)

# a.T = [ [0 3] [1 4] [2 5] ] (3,2)
# [ [0 1 2] [3 4 5] ] * [ [0 1 2] [3 4 5] ] == (2,3) * (2,3) - нельзя умножить
# [ [0 1 2] [3 4 5] ] * [ [0 3] [1 4] [2 5] ] == (2,3) * (3,2) - можно умножить

# Разница в умножении:

# [ [0 1 2] [3 4 5] ] * [ [0 3] [1 4] [2 5] ] = (2,3) * (3,2) = (2,2)
# [0 1 2] * [0 1 2] = 0*0 + 1*1 + 2*2 = 5
# [0 1 2] * [3 4 5] = 0*3 + 1*4 + 2*5 = 14
# [3 4 5] * [0 1 2] = 3*0 + 4*1 + 5*2 = 14
# [3 4 5] * [3 4 5] = 3*3 + 4*4 + 5*5 = 50
np.dot(a, a.T)      # [ [ 5, 14],  [14, 50] ]      

# [ [0 3] [1 4] [2 5] ] * [ [0 1 2] [3 4 5] ] = (3,2) * (2,3) = (3,3)
np.dot(a.T, a)      # [ [ 9, 12, 15], [12, 17, 22], [15, 22, 29]]

# Если произвольная размерность у вектора:
x = np.empty( (4,3,2,7) )   #  массив с "мусорными" значениями элементов
 
#print(x.T.shape)            # (7,2,3,4)

#endregion

#region ПЕРЕМНОЖЕНИЕ ДЛЯ ПРОИЗВОЛЬНЫХ ТЕНЗОРОВ

v1 = np.ones(2,dtype=int)       #   [1 1]               (1,2)
v2 = np.ones((2,3),dtype=int)   #   [ [1 1 1] [1 1 1] ] (2,3)
v3 = np.ones((3,1),dtype=int)   #   [ [1] [1] [1] ]     (3,1)

#print(np.dot(v2,v3))            #   (2,3) + (3,1) = [ [3] [3] ] (2,1)
#print(np.dot(v1,np.dot(v2,v3))) #   (1,2) + (2,1) = [6] (1,1)

#endregion

#region ОПЕРАЦИИ СВЕРТКИ

# @ = операция matmul

v1 = np.random.rand(1, 2, 3)
v2 = np.random.rand(3, 2, 3, 5)

# (1,2,3) @ (3,2,3,5) = (1,1,2,3) @ (3,2,3,5) = (3,2,2,3) @ (3,2,3,5) = (3,2,2,5)
# Из второго действия к третьему @ фиксирует значения последних двух тензоров
# Можно поскольку по последним двум (2,3) и (3,5), где 3 обеспечивают матричное умножение
print((v1 @ v2).shape) # (3,2,2,5)

v1 = np.random.rand(3, 2, 3)
v2 = np.random.rand(3, 2, 3, 5)

# (3,2,3) @ (3,2,3,5) = (3,2,3,1) @ (3,2,3,5) - нельзя
# Не могут быть перемножены (3,1) и (3,5) - 3 стоят на одинаковом месте
#print((v1 @ v2).shape)

# tensordot - совмещает тензоры по осям(индексам)

A = np.empty( (3,4,5) )
B = np.empty( (1,3,4,2) )
 
# [0,1] = (3) (3) - убираем если равно
# [1,2] = (4) (4) - тоже убираем
# Итого: (3,4,5) = (5) (1,3,4,2) = (1,2)
# (5) (1,2) = (5,1,2)
C = np.tensordot(A,B, axes=([0,1], [1,2]))      
#print(C.shape)                                  # (5, 1, 2)

#endregion

#region ИНИЦИАЛИЗАЦИЯ ЭЛЕМЕНТОВ

# Почему показывает значения? Откуда берет?
# она выделяет память для массива, но содержимое неопределенно
# значенея зависят от того что было в памяти на момент создания
y = np.empty( (2,3) )       # 2 строки и 3 столбца без инициализации значение
#print(y)                   # Случайные значения
     
x = np.zeros( (2,3) )       # 2 строки и 3 столбца  из нулей
#print(x)                   # Все значения с 0
x = np.ones ( (2,3) )       # 2 строки и 3 столбца  из единиц
#print(x)                   # Все значения с 1

x = np.eye(3)               # единичная матрица 3x3
#print(x)                   # По диагонали матрицы значения 1
x = np.eye(3,k=1)           # Модификатор k смещает значения для диагонали
#print(x)                    # Смещение на 1 вправо для всех значений

# Создает одномерный массив со значения от 0 до 1 размером 3
# При этом значения равномерно распределены по массиву
x = np.linspace(0, 1, 3)    # [0. , 0.5, 1. ]  (x=beg,  x <= end, num)
#print(x)

# arange - инициалицирует одномерный массив
x = np.arange(3)                      # [0, 1, 2] от 0   до end - 1
#print(x)
x = np.arange(1,3)                    # [1, 2]    от beg до end - 1
#print(x)
x = np.arange(10, 30, 5)              # [10, 15, 20, 25] (i=beg,  i < end, i+=step)
#print(x)

#Образование тензора по структуре другого тензора
y = np.empty( (2,3) )

x = np.empty_like(y)                    # той-же формы, что и y, но с "мусором"
#print(x)                                # Мусорные значения
x = np.zeros_like(y)                    # из нулей такой же формы как у тензора y
#print(x)                                # Значения с 0

# Заполнение значениями по тензору
x = np.full((2,3), 5)                   # 2x3 пятёрок (если 5 то int32; для 5. float64)
#print(x)
# Повторяет значения по тензору, то есть:
# (2,3) = (2*2,3*2) = (4,6) со значениями из y
x = np.tile(y, (2, 2))                  # замостить тензором y матрицу 2x2
#print(x)

# Смена типов данных
x = np.ones  ((4,), dtype=np.int64)
#print(x)
x = np.arange(3,    dtype=np.float32)
#print(x)

#endregion

#region СЛУЧАЙНЫЕ ТЕНЗОРЫ

# Можно задать номер для генератора случайных чисел чтобы он давал одни и те же значения
x = np.random.seed(553)                 # фиксирование сида генератора

# Выбирает одно случайное по диапозону
x = np.random.randint(0,10)           # одно целое равномерно распр. из [0...10) int32
#print(x)                              # 5
x = np.random.uniform(0,10)           # одно равномерно распр. число из [0...10) float64
#print(x)
x = np.random.normal (0, 1)           # одно гауссово сл.чисел aver=0, sigma=1   float64
#print(x)

# Генерация тензоров со случайными значениями (float)
x = np.random.random ( (2,3) )        # 2x3 равномерно распр. случайных чисел [0...1)
#print(x)
x = np.random.normal (0, 1, (10,) )   # 10 гауссовых сл.чисел aver=0, sigma=1
#print(x)

# Генерация тензора со случайными значениями (int) 
x = np.random.randint(0, 4, (10,) )   # 10 целых сл. чисел [0...3]
#print(x)
# Перемешанная последовательность от 0 до 4(включая каждое число)
x = np.random.permutation(5)          
#print(x)

# choice - выбирает числа для вектора с определенными вероятностями
# len(prob) - первое значение определяет в каком диапозоне будут значения
# второе значение сколько будет чисел в итоге сгенерировано
# третье задает вероятности для чисел
# первое и третье должны быть равны, чтобы вероятности == кол-ву значений
prob=[0.1, 0.1, 0.3, 0.25, 0.25] # 5 размер, то от 0 до 4
#print(np.random.choice(len(prob), 3, p=prob))  # [2, 2, 4]

#endregion

#region РАЗНОЕ ПОЛЕЗНОЕ

# Выборка с условием
a = np.array([0,2,4,6,8])
 
idx = a >  2                      
#print(idx)              # [False, False,  True,  True,  True]
b = a[idx]                      
#print(b)                # [4, 6, 8]

# where - если выполняет(false) или не выполняет(true) действие
a = np.arange(10)              # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
idx = a < 5                    # [True True True True True False False False False False]
#print(np.where(idx, a, 10*a))  # [0, 1, 2, 3, 4, 50,60,70,80,90]

# Как перемешивать значения в векторах(тензорах)
a = np.array([0,2,4,6,8])
b = np.array([1,3,5,7,9])
 
# a.shape - возвращает размерность
# a.shape[0] - возращает размер конкректно множества под этим номером
idx = np.random.permutation(a.shape[0])   # целые индексы в случайном порядке
a = a[idx]                                # [0 8 4 6 2]
b = b[idx]                                # [1 9 5 7 3]
#print(a,b)

# vstack - добавляет массивы друг к другу по первой размерности 
# (0,2) - 0 первая размерность
ar1 = np.array([], dtype=np.float32).reshape(0,2)   # (0,2) - пустой массив
#print(ar1)                                          # []
ar1 = np.vstack([ar1, np.zeros((1,2))])             # (0,2) + (1,2) = (1,2)
#print(ar1)                                          # [[0. 0.]]
ar1 = np.vstack([ar1, np.ones ((3,2))])             # (1,2) + (3,2) = (4,2)
#print(ar1)                                          # [[0. 0.][1. 1.][1. 1.][1. 1.]]

# set_printoptions - задает параметры для отображения чисел в массиве
arr = np.array([0.000123456, 123.456789, 0.0045678])
#print(arr)                                          # полные значения
np.set_printoptions(precision=3, suppress=True)   
#print(arr)                                          # 3 цифры после точки
#endregion