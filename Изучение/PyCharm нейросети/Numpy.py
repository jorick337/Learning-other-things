#region РАЗМЕРНОСТЬ И ФОРМА ТЕНЗОРА

import numpy as np                     #         ndim:    shape:       size: 
                                        
v = np.array( [ 1, 2, 3] )             # вектор:     1     (3,)         3 
                                  
m = np.array( [ [ 1, 2, 3],              
                [ 4, 5, 6] ])          # матрица:    2     (2, 3)       6
                                  
t = np.array( [ [[ 1, 2, 3],              
                 [ 4, 5, 6]],    
                                  
                [[ 7, 8, 9],              
                 [10,11,12]] ])        # тензор:    3      (2, 2, 3)   12

#endregion

#region ОБРАЩЕНИЕ К ВЕКТОРАМ

t1 = np.array( [ 1, 2] )             #  shape = (2,)                 
t2 = np.array( [ [1,2] ] )           #  shape = (1,2)
t3 = np.array( [[1],                 #  shape = (2,1)   
                 [2]])

t1[1] == t2[0,1] == t3[1,0] == 2    #  True

#endregion

#region КАК ИЗМЕНЯТЬ НЕ МЕНЯЯ РАЗМЕР

v = np.array( [1,2,3,4,5,6] )         # shape = (6,)    ndim = 6
m16 = v.reshape( (1,6) )                 # shape = (1,6)   ndim = 6
m23 = v
m23.shape = (2,3)                        # shape = (2,3)   ndim = 6
 
# print(f"{m23} \n\n {v}")                   #  [ [1,2,3],[4,5,6] ]
                           
#endregion

#region ВЫСЧИТЫВАНИЕ САМОСТОЯТЕЛЬНЫХ ДЛИН ТЕНЗОРОВ(ВЕКТОРОВ)

v = np.arange(12)                       # [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
 
m = v.reshape( (3, 4 ) )                # [ 
                                        #   [ 0, 1, 2, 3]
                                        #   [ 4, 5, 6, 7]
                                        #   [ 8, 9, 10, 11] 
                                        # ]
                                        
t = m.reshape( (-1, 2, 3) )             # [ 
                                        #   [
                                        #       [ [0,1,2] [3,4,5] ]
                                        #       [ [6,7,8] [9,10,11] 
                                        #   ]
                                        # ]
               
# print(v.shape, m.shape, t.shape)      # (12,) (3, 4) (2, 2, 3)

#endregion

#region ФУНКЦИИ ДЛЯ ОСЕЙ(ИНДЕКСОВ)

# Зачем точки? 
# Так указан тип float, можно добавить к ones((2, 3), dtype=int)

m = np.ones( (2, 3))                    # матрица 2x3 из единиц:   
                                        # [ 
                                        #     [1. 1. 1.]
                                        #     [1. 1. 1.]
                                        # ]

# print( m.sum(axis=0),                   #  [2. 2. 2.]  сумма по строчкам
#        m.sum(axis=1),                   #  [3. 3.]     суммы по колонками
#        m.sum()  )                       #  6.0         сумма всех элементов

#endregion

#region ВЫБОРКА ПО ИНДЕКСАМ

m = np.arange( 6 ).reshape((2,3))       # [
                                        #   [0, 1, 2],
                                        #   [3, 4, 5]
                                        # ]
                                       
v1 = m[0, :]                          #   [0, 1, 2]
v2 = m[0]                             #   тоже самое (для 1-го индекса)
v3 = m[:, 0]                          #   [0, 3]
 
mm = m[0:2, 0:2]                      # [ 
                                      #     [0, 1], 
                                      #     [3, 4]
                                      # ]
                                      
s = m[:,1]                            # [1 4]
#print(v1,v2,v3,mm, s)

#endregion

#region СМЕНА ЗНАЧЕНИЙ ПО ИНДЕКСУ

# ССЫЛОЧНЫЙ ТИП ПОЛУЧАЕТСЯ
v1[0] = 100
m.reshape(-1)
# print(m)

m[:,0] = -1                           # [[-1,  1,  2],
# print(m)                              #  [-1,  4,  5]]

m[:,1] = 52
#print(m)

#endregion

#region МАТЕМАТИЧЕСКИЕ ФУНКЦИИ

a = np.arange(3)                      # [0, 1, 2]
b = np.arange(3,6)                    # [3, 4, 5]

a + b                                 # [3, 5, 7]
a * b                                 # [0, 4,10]

# print(a + b, a* b)

#endregion

#region МАТЕМАТИЧЕСКИЕ ФУНКЦИИ КОГДА РАЗНЫЕ СТРУКТУРЫ ТЕНЗОРОВ(ВЕКТОРОВ)

m = np.array([ [0, 1],
               [2, 3]])     
                
v = np.array(  [4, 5] )

# 0 1 2 3 + 4 5 4 5 - Дублируются по колонке
#print(m+v)    # [[4, 6],
              #  [6, 8]]
              
v = np.array(  [ [4], [5] ] )

# 0 1 2 3 + 4 4 5 5 - Дублируются по строке
#print(m+v)

#endregion

#region ПРОИЗВЕДЕНИЕ И УМНОЖЕНИЕ ВЕКТОРОВ (ИХ СУММА)

u = np.array( [1,2,3] )
v = np.array( [3,2,1] )
 
#print( np.dot(u,v) )             #  10 = 1*3 + 2*2 + 3*1
#print( u.dot(v)    )             #  10 - тот же результат
#print( np.sum(u*v) )             #  10 - тот же результат

P = np.arange( 6).reshape( (2,3) )  # [ [0 1 2] [3 4 5] ]
Q = np.arange(12).reshape( (3,4) )  # [ [0 1 2 3] [4 5 6 7] [8 9 10 11] ]

# Если строк у первого меньше чем у второго, НО 
# кол-во строк первого равно кол-ву столбцов второго то:
# считать вот так(на примере 1 строки):
# [0 1 2] - первая строка первого
# [0 4 8] - первый столбец второго
# То есть где можем перемножить там и перемножаем:
# 0*0 + 1*4 + 2*8 = 20 - первое значение для них

#print(np.dot(P, Q))     # [ [20 23 26 29] [56 68 80 92] ]
#print(P.dot(Q)  )       # То же самое

P = np.array([1,2])         # (2,) == (1,2)
Q = np.array([[3],[4]])     # (2,1)

# [1 2] - первая строка первого
# [3 4] - первый столбец второго
# 1*3 + 2*4 = 11

#print(np.dot(P, Q)) # [ 11 ] 

#endregion

#region СМЕНА СТОЛБЦОВ И СТРОЧЕК

# При помощи .T или transpose()
a = np.arange(6).reshape(2,3)       # (2, 3) [ [0 1 2] [3 4 5] ]
b = a.T                            # (3, 2) [ [0 3] [1 4] [2 5] ]   

#print(b.shape)                  

v = np.arange(6)                # [0 1 2 3 4 5]
m = v.reshape(3,2)              # [ [0 1] [2 3] [4 5] ]
 
# reshape => [ [0 1] [2 3] [4 5] ] => [0 1 2 3 4 5] => [ [0 1 2] [3 4 5] ]
m1 = m.reshape(2,3)             # [ [0 1 2] [3 4 5] ]     
 
# T => [ [0 1] [2 3] [4 5] ] => [ [0 2 4] [1 3 5] ]
m2 = m.T                        # [ [0 2 4] [1 3 5] ]

#print(m1,m2)

# Ссылочный тип (транспонтирование)
m2[0,0]=52
#print(m)                        #  [ [100 1 2] [  3 4 5] ]

# Если нужно умножить на себя то нужна транспонтировка, 
# (если не квадратная матрица где кол-во столбцов не равно кол-ву строк (3,2) - нет (2,2) - да)
# поскольку не будут совпадать при умножении столбцы
a = np.arange(6).reshape(2,3)       # [ [0 1 2] [3 4 5] ] (2,3)

# a.T = [ [0 3] [1 4] [2 5] ] (3,2)
# [ [0 1 2] [3 4 5] ] * [ [0 1 2] [3 4 5] ] == (2,3) * (2,3) - нельзя умножить
# [ [0 1 2] [3 4 5] ] * [ [0 3] [1 4] [2 5] ] == (2,3) * (3,2) - можно умножить

# Разница в умножении:

# [ [0 1 2] [3 4 5] ] * [ [0 3] [1 4] [2 5] ] = (2,3) * (3,2) = (2,2)
# [0 1 2] * [0 1 2] = 0*0 + 1*1 + 2*2 = 5
# [0 1 2] * [3 4 5] = 0*3 + 1*4 + 2*5 = 14
# [3 4 5] * [0 1 2] = 3*0 + 4*1 + 5*2 = 14
# [3 4 5] * [3 4 5] = 3*3 + 4*4 + 5*5 = 50
np.dot(a, a.T)      # [ [ 5, 14],  [14, 50] ]      

# [ [0 3] [1 4] [2 5] ] * [ [0 1 2] [3 4 5] ] = (3,2) * (2,3) = (3,3)
np.dot(a.T, a)      # [ [ 9, 12, 15], [12, 17, 22], [15, 22, 29]]

# Если произвольная размерность у вектора:
x = np.empty( (4,3,2,7) )   #  массив с "мусорными" значениями элементов
 
#print(x.T.shape)            # (7,2,3,4)

#endregion

#region ПЕРЕМНОЖЕНИЕ ДЛЯ ПРОИЗВОЛЬНЫХ ТЕНЗОРОВ

v1 = np.ones(2,dtype=int)       #   [1 1]               (1,2)
v2 = np.ones((2,3),dtype=int)   #   [ [1 1 1] [1 1 1] ] (2,3)
v3 = np.ones((3,1),dtype=int)   #   [ [1] [1] [1] ]     (3,1)

#print(np.dot(v2,v3))            #   (2,3) + (3,1) = [ [3] [3] ] (2,1)
#print(np.dot(v1,np.dot(v2,v3))) #   (1,2) + (2,1) = [6] (1,1)

#endregion

#region



#endregion
#region



#endregion