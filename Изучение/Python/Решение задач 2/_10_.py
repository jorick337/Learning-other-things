#SET И FROZEN(МНОЖЕСТА):
#В МНОЖЕСТВАХ НЕТ ПОВТОРЯЮЩИХСЯ ЭЛЕМЕНТОВ

a = set("hello")#SET-МНОЖЕСТВО,КОТОРОЕ ПРИ ЕГО НАПИСАНИИ ВЫВОДИТ ВСЕ ЭЛЕМЕНТЫ В
print(type(a))#СЛУЧАЙНОМ ПОРЯДКЕ(КАЖДЫЙ РАЗ);TYPE-ПРЕОБРАЗУЕТ ЛЮБОЙ ТИП В ТОТ,
print(a)#ЧТО НУЖЕН(НЕНУЖНО САМОСТОЯТЕЛЬНО ЕГО ОПРЕДЕЛЯТЬ)
print()

#ЭТО СЛОВАРЬ 

b = {'23':32} 
print(type(b))
print(b)
print()

#НО ЕСЛИ ПИСАТЬ ЗНАЧЕНИЯ ЧЕРЕЗ ЗАПЯТУЮ,ТО ЭТО МНОЖЕСТВО SET(КОТОРОЕ ПИШЕТСЯ В 
#СЛУЧАЙНОМ ПОРЯДКЕ)
b = {'23',32} 
print(type(b))
print(b)
print()

#КАК ИСПОЛЬЗОВАТЬ:

c = {i ** 2 for i in range(10)}#В МНОЖЕСТВЕ SET ОТ 0 ДО 10 ВСЕ ЧИСЛА В СТЕПЕНИ 2 
print(type(c))#ОНИ ПИШУТСЯ В СЛУЧАЙНОМ ПОРЯДКЕ(НЕ КАЖДЫЙ РАЗ) 
print(c)#
print()#

#НЕКОТОРЫЕ ОСОБЕННОСТИ:

d = {} #ЭТО СЛОВАРЬ
D = {23}#ЭТО МНОЖЕСТВО SET
print(type(d))
print(d)
print(type(D))
print(D)
print()

#FROZENSET-МНОЖЕСТВО,КОТОРОЕ В ОТЛИЧИЕ ОТ SET НЕЛЬЗЯ ИЗМЕНИТЬ

g = set("hello")#В SET МЫ МОЖЕМ ДОБАВЛЯТЬ ЗНАЧЕНИЯ С ПОМОЩЬЮ КОМАНДЫ
g.add(1)#ADD-ДОБАВЛЯЕТ ЗНАЧЕНИЕ В МНОЖЕСТВО,КОТОРОЕ ДОБАВЛЯЕТСЯ В СЛУЧАЙНЫЙ 
print(g)#ИНДЕКС
print()

G = frozenset("hello")#FROZENSET-ТУТ НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ ДОБАВЛЕНИЕ С ПОМОЩЬЮ КО-
print(G)#МАНДЫ ADD ИНАЧЕ ОШИБКА!!!
print()

#КАК ИСПОЛЬЗОВАТЬ :

#НО! ПИШЕТСЯ В СЛУЧАЙНОМ ПОРЯДКЕ
h = [34,228,337,228,34,337]#ДОБАВЛЯЕМ СПИСОК
print(h)#ТУТ ПИШЕТСЯ ВСЕ ЕГО ЗНАЧЕНИЯ С ПОВТОРЯЮЩИМИСЯ ЗНАЧЕЯНИМИ  
print(set(h))#ТУТ ПИШЕТСЯ БЕЗ ПОВТОРЯЮЩИХСЯ ЗНАЧЕНИЙ,ЧТО УПРОЩАЕТ РАБОТУ С НИМ 
print()

#ОПЕРАЦИИ ДЛЯ МНОЖЕСТВ:
#НО! ПИШЕТСЯ В СЛУЧАЙНОМ ПОРЯДКЕ

o = {32,45,43.23,76}#СОЗДАЁМ МНОЖЕСТВО"
print(len(o))#LEN-ПИШЕТ КОЛИЧЕСТВО ПЕРЕМЕННЫХ В МНОЖЕСТВЕ
print()

x=45
print(x in o)#ПИШЕТ ЕСЛИ ЗНАЧЕНИЕ X В МНОЖЕСТВЕ O
print()

u = {67,89,23}#СОЗДАЁМ МНОЖЕСТВО
print(o.isdisjoint(u))#ISDISJOINT-ВЫВОДИТ TRUE,ЕСЛИ ЕСТЬ СХОЖЫЕ ЗНАЧЕНИЯ
print()

print(o == u)#ПРОВЕРЯЕТ ВСЕ ЛИ ЭЛЕМЕНТЫ ОДИНАКОВЫЕ;ИНДЕКСЫ ТУТ НЕ ИМЕЮТ ЗНАЧЕНИЯ)
print()

o.update(u)#UPDATE-ДОБАВЛЯЕТ ЗНАЧЕНИЯ ИЗ ОДНОГО МНОЖЕСТВА В ДРУГОЕ, 
print(o)#ЕСЛИ ТАКИХ ЗНАЧЕНИЙ НЕТ В НЁМ
print()

o.intersection_update(u)#INTERSECTION_UPDATE-ОСТАВЛЯЕТ В МНОЖЕСТВЕ ТОЛЬКО ЗНАЧЕ-
print(o)#НИЯ,КОТОРЫЕ ЕСТЬ И В ТОМ И В ДРУГОМ
print()

o.difference_update(h)#DIFFERENCE-ПИШЕТ ЗНАЧЕНИЯ,КОТОРЫЕ ЕСТЬ В ЭТОМ МНОЖЕСТВЕ,
print(o)#НО НЕТ В ДРУГОМ
print()

o.symmetric_difference_update(h)#SYMMETRIC_DIFFERCE_UPDATE-КОМАНДА ПИШЕТ ТО,ЧТО
print(o)#ЕСТЬ В ОДНОМ ИЗ МНОЖЕСТВ,НО НЕТ В ОБОИХ,ТОЕСТЬ {2,3,4} И {3,6,4} ->
print()# {2,6};ПРИ ЭТОМ ЗНАЧЕНИЯ НЕ ПОВТОРЯЮТСЯ

o.remove(228)#REMOVE-УДАЛЯЕТ ЗНАЧЕНИЕ ИЗ МНОЖЕСТВА ПРИ ЭТОМ ИНДЕКСЫ СМЕЩАЮТСЯ
print(o)#НО ЕСЛИ НЕ УДАЛИТ ОШИБКА
print()

o.discard(22)#DISCARD-УДАЛЯЕТ ЗНАЧЕНИЕ ИЗ МНОЖЕСТВА ПРИ ЭТОМ ИНДЕКСЫ СМЕЩАЮТСЯ
print(o)#НО ПРИ ЭТОМ,ЕСЛИ НЕ НАХОДИТ ЗНАЧЕНИЕ НЕ ВЫДАСТ ОШИБКИ
print()

o.pop()#POP-ОЧИЩАЕТ НУЛЕВОЙ ИНДЕКС ПРИ ЭТОМ ИНДЕКСЫ СМЕЩАЮТСЯ
print(o)
print()

o.clear()#CLEAR-УДАЛЯЕТ ВСЕ ЗНАЧЕНИЯ МНОЖЕСТВА ПРИ ЭТОМ ПИШЕТСЯ ВИД МНОЖЕСТВА И
print(o)#ЕГО ЗНАЧЕНИЯ В СКОБКАХ
print()










