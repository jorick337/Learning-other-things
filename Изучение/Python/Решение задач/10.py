#Словари

#1.
#Номер появления слова
#В единственной строке записан текст. Для каждого слова из данного текста 
#подсчитайте, сколько раз оно встречалось в этом тексте ранее.
#Словом считается последовательность непробельных символов идущих подряд,
#слова разделены одним или большим числом пробелов или символами конца строки.

a=dict()
for word in input().split():
    a[word]=a.get(word,0)+1
    print(a[word]-1,end=' ')
print('\n')

#2.
#Словарь синонимов
#Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к
#парному ему слову. Все слова в словаре различны.
#Для слова из словаря, записанного в последней строке, определите его синоним.

#МОЁ:
a=dict([input().split() for i in range(1)])
b='e'
for key,val in a.items():
    if key==b:
        val==key
    if val==b:
        key==val
print(a[b])
#ЧУЖОЕ:
#n = int(input())
#d = {}
#for i in range(n):
#    first, second = input().split()
#    d[first] = second
#    d[second] = first
#print(d[input()])
print()

#3.
#Выборы в США
#Как известно, в США президент выбирается не прямым голосованием, а путем
#двухуровневого голосования. Сначала проводятся выборы в каждом штате и
#определяется победитель выборов в данном штате. Затем проводятся
#государственные выборы: на этих выборах каждый штат имеет определенное число
#голосов — число выборщиков от этого штата. На практике, все выборщики от штата
#голосуют в соответствии с результами голосования внутри штата, то есть на
#заключительной стадии выборов в голосовании участвуют штаты, имеющие различное
#число голосов.
#В первой строке дано количество записей. Далее, каждая запись содержит фамилию
#кандидата и число голосов, отданных за него в одном из штатов. Подведите итоги
#выборов: для каждого из участника голосования определите число отданных за него
#голосов. Участников нужно выводить в алфавитном порядке.

n,a=0,dict()
for i in range(n):
    key,val=[i for i in input().split()]
    a[key]=a.get(key,0)+int(val)
for key,val in sorted(a.items()):
    print(key,val)
print()

#4.
#Самое частое слово
#Дан текст: в первой строке задано число строк, далее идут сами строки. Выведите
#слово, которое в этом тексте встречается чаще всего. Если таких слов несколько,
#выведите то, которое меньше в лексикографическом порядке.

n,a=1,dict()
for i in range(n):
    b=[i for i in input().split()]
    for l in b:
        a[l]=a.get(l,0)+1
o=max(a.values())
c=[k for k,v in a.items() if v==o]
print(min(c))    
print()

#5.
#Права доступа
#В файловую систему одного суперкомпьютера проник вирус, который сломал
#контроль за правами доступа к файлам. Для каждого файла известно, с какими
#действиями можно к нему обращаться:запись W,чтение R,запуск X.
#В первой строке содержится число N — количество файлов содержащихся в данной
#файловой системе. В следующих N строчках содержатся имена файлов и допустимых
#с ними операций, разделенные пробелами. Далее указано чиcло M — количество
#запросов к файлам. В последних M строках указан запрос вида Операция Файл.
#К одному и тому же файлу может быть применено любое колличество запросов.
#Вам требуется восстановить контроль над правами доступа к файлам
#(ваша программа для каждого запроса должна будет возвращать OK если над файлом
#выполняется допустимая операция, или же Access denied, если операция
#недопустима.

n,m=0,0
a,b={},{'read':'R','write':'W','execute':'X'}
for i in range(n):
    key,*val=input().split(' ')
    a[key]=set(val)
for i in range(m):
    key1,key2=input().split(' ')
    if  b[key1] in a[key2]:
        print('OK')
    else:
        print('Access denied')
print()

#6.
#Частотный анализ
#Дан текст: в первой строке записано количество строк в тексте, а затем сами
#строки. Выведите все слова, встречающиеся в тексте, по одному на каждую строку.
#Слова должны быть отсортированы по убыванию их количества появления в тексте, а
#при одинаковой частоте появления — в лексикографическом порядке.
#Указание. После того, как вы создадите словарь всех слов, вам захочется
#отсортировать его по частоте встречаемости слова. Желаемого можно добиться,
#если создать список, элементами которого будут кортежи из двух элементов:
#частота встречаемости слова и само слово. Например, [(2, 'hi'), (1, 'what'),
#(3, 'is')]. Тогда стандартная сортировка будет сортировать список кортежей,
#при этом кортежи сравниваются по первому элементу, а если они равны — то по
#второму. Это почти то, что требуется в задаче.

from collections import Counter
 
words , n= [],0
for _ in range(n):
    words.extend(input().split())

counter = Counter(words)
pairs = [(-pair[1], pair[0]) for pair in counter.most_common()]
print(pairs)
words = [pair[1] for pair in sorted(pairs)]
print(words)
print('\n'.join(words))
print()

#7.
#СТРАНЫ И ГОРОДА
#Дан список стран и городов каждой страны. Затем даны названия городов. Для
#каждого города укажите, в какой стране он находится.

n,m=0,0
a={}
for i in range(n):
    key,*val=input().split()
    a[key]=val
for i in range(m):
    o=str(input())
    print(' '.join([k for k,v in a.items() if o in v]))
    #for k,v in a.items():
     #   if o in v:
       #     print(k)
print()

#8.
#Англо-латинский словарь
#Однажды, разбирая старые книги на чердаке, школьник Вася нашёл англо-латинский
#словарь. Английский он к тому времени знал в совершенстве, и его мечтой было
#изучить латынь. Поэтому попавшийся словарь был как раз кстати.
#К сожалению, для полноценного изучения языка недостаточно только одного словаря
#: кроме англо-латинского необходим латинско-английский. За неимением лучшего
#он решил сделать второй словарь из первого.
#Как известно, словарь состоит из переводимых слов, к каждому из которых
#приводится несколько слов-переводов. Для каждого латинского слова,
#встречающегося где-либо в словаре, Вася предлагает найти все его переводы
#(то есть все английские слова, для которых наше латинское встречалось в его
#списке переводов), и считать их и только их переводами этого латинского слова.
#Помогите Васе выполнить работу по созданию латинско-английского словаря из
#англо-латинского.
#В первой строке содержится единственное целое число N — количество английских
#слов в словаре. Далее следует N описаний. Каждое описание содержится в
#отдельной строке, в которой записано сначала английское слово, затем отделённый
#пробелами дефис, затем разделённые запятыми с пробелами переводы этого
#английского слова на латинский. Все слова состоят только из маленьких латинских
#букв. Переводы отсортированы в лексикографическом порядке. Порядок следования
#английских слов в словаре также лексикографический.
#Выведите соответствующий данному латинско-английский словарь, в точности
#соблюдая формат входных данных. В частности, первым должен идти перевод
#лексикографически минимального латинского слова, далее — второго в этом порядке
#и т.д. Внутри перевода английские слова должны быть также отсортированы
#лексикографически.

#МОЁ
n=0
for i in range(n):
    key,*val=input().replace(', ',' ').split()
    a[key]=val
b,c=[],[]
for key,val in a.items():
    for i in val:
        if i!='-' and i not in b:
             b.append(i)
for i in sorted(b):
   for l in a.keys():
        if i in a[l]:
            print(i + ' - '+ l)
#ЧУЖОЕ
from collections import defaultdict
 
latin_to_english = defaultdict(list)
for i in range(0):
    english_word,latin_translations_chunk  = input().split(' - ')
    latin_translations = latin_translations_chunk.split(', ')
    for latin_word in latin_translations:
        latin_to_english[latin_word].append(english_word)
#print(len(latin_to_english))
#for latin_word, english_translations in sorted(latin_to_english.items()):
#    print(latin_word + ' - ' + ', '.join(english_translations))

#9.
#Контрольная по ударениям
#Учительница задала Пете домашнее задание — в заданном тексте расставить
#ударения в словах, после чего поручила Васе проверить это домашнее задание.
#Вася очень плохо знаком с данной темой, поэтому он нашел словарь, в котором
#указано, как ставятся ударения в словах. К сожалению, в этом словаре
#присутствуют не все слова. Вася решил, что в словах, которых нет в словаре, он
#будет считать, что Петя поставил ударения правильно, если в этом слове Петей
#поставлено ровно одно ударение.
#Оказалось, что в некоторых словах ударение может быть поставлено больше, чем
#одним способом. Вася решил, что в этом случае если то, как Петя поставил
#ударение, соответствует одному из приведенных в словаре вариантов, он будет
#засчитывать это как правильную расстановку ударения, а если не соответствует,
#то как ошибку.
#Вам дан словарь, которым пользовался Вася и домашнее задание, сданное Петей.
#Ваша задача — определить количество ошибок, которое в этом задании насчитает
#Вася.
#Вводится сначала число N — количество слов в словаре.
#Далее идет N строк со словами из словаря. Каждое слово состоит не более чем
#из 30 символов. Все слова состоят из маленьких и заглавных латинских букв.
#В каждом слове заглавная ровно одна буква — та, на которую попадает ударение.
#Слова в словаре расположены в алфавитном порядке. Если есть несколько
#возможностей расстановки ударения в одном и том же слове, то эти варианты в
#словаре идут в произвольном порядке.
#Далее идет упражнение, выполненное Петей. Упражнение представляет собой строку
#текста, суммарным объемом не более 300000 символов. Строка состоит из слов,
#которые разделяются между собой ровно одним пробелом. Длина каждого слова не
#превышает 30 символов. Все слова состоят из маленьких и заглавных латинских
#букв (заглавными обозначены те буквы, над которыми Петя поставил ударение).
#Петя мог по ошибке в каком-то слове поставить более одного ударения или не
#поставить ударения вовсе.
#Выведите количество ошибок в Петином тексте, которые найдет Вася.
#Примечания к примерам тестов:
#1. В слове cannot, согласно словарю возможно два варианта расстановки ударения.
#Эти варианты в словаре могут быть перечислены в любом порядке
#(т.е. как сначала cAnnot, а потом cannOt, так и наоборот).
#Две ошибки, совершенные Петей — это слова be (ударение вообще не поставлено)
#и fouNd (ударение поставлено неверно). Слово thE отсутствует в словаре,
#но поскольку в нем Петя поставил ровно одно ударение, признается верным.
#2.Неверно расставлены ударения во всех словах, кроме The
#(оно отсутствует в словаре, в нем поставлено ровно одно ударение).
#В остальных словах либо ударные все буквы (в слове PAGE),либо не поставлено
#ни одного ударения.

n = 0
accents = {}
for i in range(n):
    word = input()
    base_form = word.lower()
    if base_form not in accents:
        accents[base_form] = set()
    accents[base_form].add(word)
errors = 0
#sent = input().split()
#for word in sent:
#    base_form = word.lower()
#    if (base_form in accents and word not in accents[base_form]
#        or len([l for l in word if l.isupper()]) != 1):
#        errors+=1
print(errors,'\n')

#10.
#Родословная: подсчет уровней
#В генеалогическом древе у каждого человека, кроме родоначальника, есть ровно
#один родитель.
#Каждом элементу дерева сопоставляется целое неотрицательное число, называемое
#высотой. У родоначальника высота равна 0, у любого другого элемента высота на
#1 больше, чем у его родителя.
#Вам дано генеалогическое древо, определите высоту всех его элементов.
#Программа получает на вход число элементов в генеалогическом древе N.
#Далее следует N−1 строка, задающие родителя для каждого элемента древа, кроме
#родоначальника. Каждая строка имеет вид имя_потомка имя_родителя.
#Программа должна вывести список всех элементов древа в лексикографическом
#порядке. После вывода имени каждого элемента необходимо вывести его высоту.
#Примечание:
#Эта задача имеет решение сложности O(n), но вам достаточно написать решение
#сложности O(n2) (не считая сложности обращения к элементам словаря).

def height(man):
    if man not in p_tree:
        return 0
    else:
        return 1 + height(p_tree[man])
p_tree = {}
n = 0
for i in range(n - 1):
    child, parent = input().split()
    p_tree[child] = parent
heights = {}
for man in set(p_tree.keys()).union(set(p_tree.values())):
    heights[man] = height(man)
print(heights)
for key, value in sorted(heights.items()):
    print(key, value)
print()

#11.
#Родословная: предки и потомки
#Даны два элемента в дереве. Определите, является ли один из них потомком
#другого.
#Во входных данных записано дерево в том же формате, что и в предыдущей задаче
#Далее идет число запросов K. В каждой из следующих K строк, содержатся имена
#двух элементов дерева. 
#Для каждого такого запроса выведите одно из трех чисел: 1, если первый элемент
#является предком второго, 2, если второй является предком первого или 0, если
#ни один из них не является предком другого.
   
def is_ancestor(man, older_man):
    if man == older_man:
        return True
    while man in p_tree:
        print('\n',man)
        man = p_tree[man]
        if man == older_man:
            return True
    return False
p_tree = dict()
n = 0
for i in range(n - 1):
    child, parent = input().split()
    p_tree[child] = parent
print(p_tree)
for i in range(0):
    first, second = input().split()
    if is_ancestor(second, first):
        print(1, end=' ')
    elif is_ancestor(first, second):
        print(2, end=' ')
    else:
        print(0, end=' ')
print()

#12.
#Родословная: LCA
#В генеалогическом древе определите для двух элементов их наименьшего общего
#предка (Lowest Common Ancestor). Наименьшим общим предком элементов A и B
#является такой элемент C, что С является предком A, C является предком B, при
#этом глубина C является наибольшей из возможных. При этом элемент считается
#своим собственным предком.
#Формат входных данных аналогичен предыдущей задаче       
#Для каждого запроса выведите наименьшего общего предка данных элементов.

def LCA(name1,a):
    result=[]
    result.append(name1)
    while name1 in a:
        name1=a[name1]
        result.append(name1)
    return result
n,m=9,3
a={}
for i in range(n-1):
    child,parent=input().split()
    a[child]=parent
for k in range(m):
    name1,name2=input().split()
    c=set(LCA(name1,a))
    for d in LCA(name2,a):
        if d in c:
            print(d)
            break

















